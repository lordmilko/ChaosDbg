﻿<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="$(SolutionDir)src\ChaosDbg.Engine\bin\$(Configuration)\ChaosDbg.Engine.dll" #>
<#@ assembly name="$(SolutionDir)src\ChaosDbg.Engine\bin\$(Configuration)\ChaosLib.dll" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="ChaosDbg.Detour" #>
<#@ import namespace="ChaosLib" #>
<#@ output extension=".cs" #>
/*************************************************************************
 * This code was generated by a tool.                                    *
 * Please do not modify this file directly - modify Delegates.tt instead *
 *************************************************************************/
using System;
using System.Runtime.InteropServices;
using ChaosLib;
using ClrDebug;
using ClrDebug.DbgEng;
using ClrDebug.DIA;

namespace ChaosDbg.Detour
{
    internal static class Delegates
    {
<#
var types = new Type[]
{
};

foreach (var type in types)
{
    var generator = new PInvokeDelegateGenerator(type);
    var strs = generator.Execute();
#>
        #region <#= type.DeclaringType.Name #>

<#
    for (var i = 0; i < strs.Length; i++)
    {
#>
        <#= strs[i] #>
<#
        if (i < strs.Length - 1)
        {
#>

<#
        }
    }
#>

        #endregion
<#
}
#>
    }
}
<#+
class PInvokeDelegateGenerator
{
    private Type parentType;

    public PInvokeDelegateGenerator(Type parentType)
    {
        this.parentType = parentType;
    }

    public string[] Execute()
    {
        var methods = parentType.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic).Where(v => v.Attributes.HasFlag(MethodAttributes.PinvokeImpl)).ToArray();

        var results = new List<string>();

        foreach (var method in methods)
        {
            var raw = GenerateDelegate(method);
            results.Add(raw.normalDelegate);
            results.Add(raw.hookDelegate);
        }

        return results.ToArray();
    }

    private (string normalDelegate, string hookDelegate) GenerateDelegate(MethodInfo method)
    {
        var parameters = method.GetParameters();

        var normalBuilder = new StringBuilder();
        var hookBuilder = new StringBuilder();

        void AppendBoth(string str)
        {
            normalBuilder.Append(str);
            hookBuilder.Append(str);
        }

        var detourFunctionInfo = new DetourFunctionInfo(method, method.Name, 0);
        AppendBoth("internal delegate ");

        var methodSignature = string.Join(Environment.NewLine, detourFunctionInfo.GetSignature("Delegate", includeAttribs: true).Replace("\r", string.Empty).Split('\n').Select(v => $"            {v}")).Trim();
        var hookSignature = string.Join(Environment.NewLine, detourFunctionInfo.GetSignature("HookDelegate", includeAttribs: false).Replace("\r", string.Empty).Split('\n').Select(v => $"            {v}")).Trim();

        normalBuilder.Append(methodSignature).Append(";");

        hookSignature = hookSignature.Substring(0, hookSignature.Length - 1);

        if (detourFunctionInfo.Parameters.Length > 0)
            hookSignature += ",";

        hookBuilder.Append(hookSignature + Environment.NewLine + "            " + $"{method.Name}Delegate original);");
        return (normalBuilder.ToString(), hookBuilder.ToString());
    }
}
#>